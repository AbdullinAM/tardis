package tardis.implementation.evosuite;

import static jbse.common.Type.splitParametersDescriptors;
import static tardis.implementation.common.Util.getInternalClassloader;

import java.io.BufferedWriter;
import java.io.IOException;
import java.lang.reflect.Array;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import com.github.javaparser.StaticJavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.ImportDeclaration;
import com.github.javaparser.ast.NodeList;
import com.github.javaparser.ast.body.ClassOrInterfaceDeclaration;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.body.Parameter;
import com.github.javaparser.ast.body.VariableDeclarator;
import com.github.javaparser.ast.expr.Expression;
import com.github.javaparser.ast.expr.MethodCallExpr;
import com.github.javaparser.ast.expr.Name;
import com.github.javaparser.ast.expr.ObjectCreationExpr;
import com.github.javaparser.ast.expr.SimpleName;
import com.github.javaparser.ast.stmt.ExpressionStmt;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.ast.type.ClassOrInterfaceType;
import com.github.javaparser.ast.type.Type;
import com.github.javaparser.ast.visitor.ModifierVisitor;
import com.github.javaparser.ast.visitor.Visitable;

import tardis.Options;
import tardis.implementation.jbse.JBSEResult;

final class SeedSplitter {
    /**
     * Splits a seed test class generated by EvoSuite, 
     * with multiple test methods, into multiple classes
     * with a single test method.
     * 
     * @param testCountInitial an {@code int}, the number used to identify 
     *        the generated tests. The test generated will be numbered starting 
     *        from {@code testCountInitial} henceforth.
     * @param targetClassName a {@link String}, the name of the target class.
     * @return a {@link List}{@code <}{@link JBSEResult}{@code >}.
     * @throws IOException if some I/O error occurs during the execution of Javaparser.
     * @throws IOFileCreationException if some I/O error occurs while creating the 
     *         test class or scaffolding class, or the folder that must contain them.
     * @throws NoTestFileException if the test file does not exist.
     * @throws NoTestFileScaffoldingException if the scaffolding file does not exist. 
     */
    static List<JBSEResult> splitEvosuiteSeed(Options o, List<List<String>> visibleTargetMethods, int testCountInitial, String targetClassName) 
    throws NoTestFileException, NoTestFileScaffoldingException, IOException, IOFileCreationException {
    	//defines the names of classes/compilation units, 
    	//and checks their existence
        final String testClassName = targetClassName + "_Seed_Test";
        final String scaffClassName = (o.getEvosuiteNoDependency() ? null : testClassName + "_scaffolding");
        final Path testFile = o.getTmpTestsDirectoryPath().resolve(testClassName + ".java");
        final Path scaffFile = (o.getEvosuiteNoDependency() ? null : o.getTmpTestsDirectoryPath().resolve(scaffClassName + ".java"));
        checkTestExistence(testFile, scaffFile);
        
        //parses the seed compilation unit
    	final CompilationUnit cuTestClass = StaticJavaParser.parse(testFile);
        
        //finds all the test method declarations 
        //in the compilation unit
        final ArrayList<MethodDeclaration> testMethodDeclarations = 
        testMethodsInCompilationUnit(cuTestClass);
        
        //generates all the split classes and the return value
        final ArrayList<JBSEResult> retVal = new ArrayList<>();
        int testCount = testCountInitial;
        for (MethodDeclaration mdTest : testMethodDeclarations) {
            //builds a map of variable declarations (variable names to
            //class names)
            final HashMap<String, Class<?>> varDecls = variableDeclarationsMap(cuTestClass, mdTest);
            
            //gets all the statements in the method
            final List<ExpressionStmt> stmts = mdTest.findAll(ExpressionStmt.class);
            Collections.reverse(stmts); //from last to first one
            
            //scans all the statements and builds a test class
            //for each target method call
            for (ExpressionStmt stmt : stmts) {
                //looks for a method/constructor call in the statement
                final Expression expr = findMethodOrConstructorCall(stmt);
                if (expr == null) {
                	continue;
                }
                
                //determines if the invoked method/constructor is a target method
                final List<String> targetMethod = 
                findVisibleTargetMethod(expr, varDecls, visibleTargetMethods);
                if (targetMethod == null) {
                    continue;
                }

                //defines the names of the new classes
                final String testClassNameNew = (targetClassName + "_" + testCount + "_Test");
                final String scaffClassNameNew = (o.getEvosuiteNoDependency() ? null : testClassNameNew + "_scaffolding");

                //creates the declaration for the test class
                final ClassOrInterfaceDeclaration cdeclTestClassNew = 
                createDeclarationTestClass(targetClassName, testClassNameNew, mdTest, stmt);
                
                //creates the compilation unit for the scaffolding, 
                //and possibly patches the declaration for the test class
                final CompilationUnit cuTestScaffNew;
                if (o.getEvosuiteNoDependency()) {
                	cuTestScaffNew = null;
                } else {
                	cuTestScaffNew = createCompilationUnitScaffoldingClass(scaffFile, scaffClassName, scaffClassNameNew);
                	patchCompilationUnitTestClassSuperclass(cdeclTestClassNew, scaffClassName, scaffClassNameNew);
                }

                //creates the compilation unit for the test class
                final CompilationUnit cuTestClassNew = 
                createCompilationUnitTestClass(testClassName, cuTestClass, cdeclTestClassNew);

                //writes the compilation units to files
                writeCompilationUnits(o, testClassNameNew, cuTestClassNew, scaffClassNameNew, cuTestScaffNew);
                
                //creates the new item
                final JBSEResult newItem = new JBSEResult(targetMethod);
                retVal.add(newItem);

                ++testCount;
            }
        }
        
        return retVal;
    }
    
    private static void checkTestExistence(Path testFile, Path scaffFile) 
    throws NoTestFileException, NoTestFileScaffoldingException {
        if (!testFile.toFile().exists()) {
            throw new NoTestFileException(testFile);
        }
        if (scaffFile != null && !scaffFile.toFile().exists()) {
            throw new NoTestFileScaffoldingException(scaffFile);
        }
    }
    
    private static ArrayList<MethodDeclaration> testMethodsInCompilationUnit(CompilationUnit cuTestClass) {
        final ArrayList<MethodDeclaration> retVal = new ArrayList<>();
        cuTestClass.findAll(MethodDeclaration.class).forEach(md -> {
            if (md.isAnnotationPresent("Test")) {
                retVal.add(md);
            }
        });
        return retVal;
    }
    
    private static HashMap<String, Class<?>> variableDeclarationsMap(CompilationUnit cuTestClass, MethodDeclaration mdTest) {
        final HashMap<String, Class<?>> retVal = new HashMap<>();
        mdTest.findAll(VariableDeclarator.class).forEach(vd -> {
            retVal.put(vd.getNameAsString(), javaTypeToClass(cuTestClass, vd.getTypeAsString()));
        });
        return retVal;
    }
    
    private static Expression findMethodOrConstructorCall(ExpressionStmt stmt) {
    	final Expression expr;
        if (stmt.getExpression().isMethodCallExpr()) {
            expr = stmt.getExpression();
        } else if (stmt.getExpression().isObjectCreationExpr()) { //unlikely
            expr = stmt.getExpression();
        } else if (stmt.getExpression().isAssignExpr() && stmt.getExpression().asAssignExpr().getValue().isMethodCallExpr()) {
            expr = stmt.getExpression().asAssignExpr().getValue();
        } else if (stmt.getExpression().isAssignExpr() && stmt.getExpression().asAssignExpr().getValue().isObjectCreationExpr()) {
            expr = stmt.getExpression().asAssignExpr().getValue();
        } else if (stmt.getExpression().isVariableDeclarationExpr() && stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().isPresent() &&
                   stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().get().isMethodCallExpr()) {
            expr = stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().get();
        } else if (stmt.getExpression().isVariableDeclarationExpr() && stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().isPresent() &&
                   stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().get().isObjectCreationExpr()) {
            expr = stmt.getExpression().asVariableDeclarationExpr().getVariable(0).getInitializer().get();
        } else {
            expr = null; //gives up
        }
        return expr;
    }
    
    private static List<String> findVisibleTargetMethod(Expression expr, HashMap<String, Class<?>> varDecls, List<List<String>> visibleTargetMethods) {
    	//finds the name and the list of parameters type for the method specified by expr
        final String methodName = (expr instanceof MethodCallExpr ? ((MethodCallExpr) expr).getNameAsString() : "<init>" );
        final ArrayList<Class<?>> argumentTypes = new ArrayList<>();
        for (Expression e : (expr instanceof MethodCallExpr ? ((MethodCallExpr) expr).getArguments() : ((ObjectCreationExpr) expr).getArguments())) {
            argumentTypes.add(inferType(e, varDecls));
        }
        
        //looks for a visible target method with same name and parameters list 
        List<String> targetMethod = null;
        visibleTargetMethodsLoop:
        for (List<String> visibleTargetMethod : visibleTargetMethods) {
            if (visibleTargetMethod.get(2).equals(methodName)) {
                final String[] visibleTargetMethodArgumentTypes = splitParametersDescriptors(visibleTargetMethod.get(1));
                if (visibleTargetMethodArgumentTypes.length == argumentTypes.size()) {
                    boolean allMatch = true;
                    allMatchLoop:
                    for (int i = 0; i < visibleTargetMethodArgumentTypes.length; ++i) {
                        final Class<?> argClass = argumentTypes.get(i); 
                        final Class<?> targetMethodArgClass = classFileTypeToClass(visibleTargetMethodArgumentTypes[i]);
                        if (argClass != null && targetMethodArgClass != null && !targetMethodArgClass.isAssignableFrom(argClass)) {
                            allMatch = false;
                            break allMatchLoop;
                        }
                    }
                    if (allMatch) {
                        targetMethod = visibleTargetMethod;
                        break visibleTargetMethodsLoop;
                    }
                }
            }
        }
        return targetMethod;
    }
    
    private static ClassOrInterfaceDeclaration createDeclarationTestClass(String targetClassName, String testClassNameNew, MethodDeclaration mdTest, ExpressionStmt stmt) {
        //creates a new test class declaration
        final ClassOrInterfaceDeclaration cdeclTestClass = (ClassOrInterfaceDeclaration) mdTest.getParentNode().get();
        final ClassOrInterfaceDeclaration retVal = cdeclTestClass.clone();
        
        //detects the test method to preserve
        final MethodDeclaration mdTestNew = retVal.getMethodsBySignature(mdTest.getNameAsString(), mdTest.getParameters().stream().map(Parameter::getType).map(Type::toString).toArray(String[]::new)).get(0);
        
        //removes all the other test methods
        final ArrayList<MethodDeclaration> toExpunge = new ArrayList<>();
        retVal.findAll(MethodDeclaration.class).forEach(md -> {
            if (md.isAnnotationPresent("Test") && !md.equals(mdTestNew)) {
                toExpunge.add(md);
            }
        });
        for (MethodDeclaration md : toExpunge) {
            retVal.remove(md);
        }
        
        //changes the name to the only test method
        mdTestNew.setName("test0");
        
        //removes all the statements after stmt
        final List<Statement> stmts = mdTestNew.findAll(Statement.class);
        Collections.reverse(stmts); //from last to first one
        for (Statement curStmt : stmts) {
        	if (curStmt.equals(stmt)) {
        		break;
        	}
        	mdTestNew.getBody().get().remove(curStmt);
        }
        
        //changes the name to the test class
        final String testClassNameNew_Unqualified = testClassNameNew.substring(testClassNameNew.lastIndexOf('/') + 1);
        retVal.setName(testClassNameNew_Unqualified);
        return retVal;
    }
    
    private static CompilationUnit createCompilationUnitTestClass(String testClassName, CompilationUnit cuTestClass, ClassOrInterfaceDeclaration cdeclTestClassNew) {
        final CompilationUnit retVal = cuTestClass.clone();
        final String testClassName_Unqualified = testClassName.substring(testClassName.lastIndexOf('/') + 1);
        final ClassOrInterfaceDeclaration cdeclTestClass = retVal.findFirst(ClassOrInterfaceDeclaration.class, cid -> cid.getName().asString().equals(testClassName_Unqualified)).get();
        retVal.replace(cdeclTestClass, cdeclTestClassNew);
        return retVal;
    }
    
    private static CompilationUnit createCompilationUnitScaffoldingClass(Path scaffFile, String scaffClassName, String scaffClassNameNew) throws IOException {
    	final String scaffClassName_Unqualified = scaffClassName.substring(scaffClassName.lastIndexOf('/') + 1);
    	final String scaffClassNameNew_Unqualified = scaffClassNameNew.substring(scaffClassNameNew.lastIndexOf('/') + 1);
    	
    	//creates the compilation unit for the new scaffolding class
    	final CompilationUnit cuTestScaffNew = StaticJavaParser.parse(scaffFile);
    	final ClassOrInterfaceDeclaration scaffClassDeclarationNew = cuTestScaffNew.findFirst(ClassOrInterfaceDeclaration.class, cid ->  cid.getName().asString().equals(scaffClassName_Unqualified)).get();
    	scaffClassDeclarationNew.setName(scaffClassNameNew_Unqualified);

    	//fixes the initializeClasses method
    	final RenamerVisitor v = new RenamerVisitor(scaffClassName_Unqualified, scaffClassNameNew_Unqualified);
    	cuTestScaffNew.accept(v, null);
    	    	
    	return cuTestScaffNew;
    }
    
    private static void patchCompilationUnitTestClassSuperclass(ClassOrInterfaceDeclaration cdeclTestClassNew, String scaffClassName, String scaffClassNameNew) {
    	final String scaffClassName_Unqualified = scaffClassName.substring(scaffClassName.lastIndexOf('/') + 1);
    	final String scaffClassNameNew_Unqualified = scaffClassNameNew.substring(scaffClassNameNew.lastIndexOf('/') + 1);
    	
    	//patches the "extends" declaration of the test class
    	//declaration to point to the new scaffolding class declaration
    	final NodeList<ClassOrInterfaceType> testClassExtensions = cdeclTestClassNew.getExtendedTypes();
    	for (Iterator<ClassOrInterfaceType> it = testClassExtensions.iterator(); it.hasNext(); ) {
    		final ClassOrInterfaceType testClassExtension = it.next();
    		if (testClassExtension.getName().asString().equals(scaffClassName_Unqualified)) {
    			it.remove();
    			break;
    		}
    	}
    	cdeclTestClassNew.addExtendedType(scaffClassNameNew_Unqualified);
    }
    
    private static void writeCompilationUnits(Options o, String testClassNameNew, CompilationUnit cuTestClassNew, String scaffClassNameNew, CompilationUnit cuTestScaffNew) 
    throws IOFileCreationException {
        final Path testFileNew = o.getTmpTestsDirectoryPath().resolve(testClassNameNew + ".java");
        try {
            Files.createDirectories(testFileNew.getParent());
        } catch (IOException e) {
            throw new IOFileCreationException(e, testFileNew.getParent());
        }
        try (final BufferedWriter w = Files.newBufferedWriter(testFileNew)) {
            w.write(cuTestClassNew.toString());
        } catch (IOException e) {
            throw new IOFileCreationException(e, testFileNew);
        }
        final Path scaffFileNew;
        if (o.getEvosuiteNoDependency()) {
            scaffFileNew = null; //nothing else to write
        } else {
            scaffFileNew = o.getTmpTestsDirectoryPath().resolve(scaffClassNameNew + ".java");
            try (final BufferedWriter w = Files.newBufferedWriter(scaffFileNew)) {
                w.write(cuTestScaffNew.toString());
            } catch (IOException e) {
                throw new IOFileCreationException(e, testFileNew);
            }
        }
    }
    
    private static final class RenamerVisitor extends ModifierVisitor<Void> {
        private final String from, to;
        
        public RenamerVisitor(String from, String to) {
            this.from = from;
            this.to = to;
        }
        
        @Override
        public Visitable visit(SimpleName n, Void arg) {
            if (n.asString().equals(this.from)) {
                n.setIdentifier(this.to);
            }
            return super.visit(n, arg);
        }
        
        @Override
        public Visitable visit(Name n, Void arg) {
            if (n.asString().equals(this.from)) {
                n.setIdentifier(this.to);
            }
            return super.visit(n, arg);
        }
    }
    
    private static Class<?> javaTypeToClass(CompilationUnit cu, String type) {
        if ("boolean".equals(type)) {
            return boolean.class;
        } else if ("byte".equals(type)) {
            return byte.class;
        } else if ("char".equals(type)) {
            return char.class;
        } else if ("double".equals(type)) {
            return double.class;
        } else if ("float".equals(type)) {
            return float.class;
        } else if ("int".equals(type)) {
            return int.class;
        } else if ("long".equals(type)) {
            return long.class;
        } else if ("short".equals(type)) {
            return short.class;
        } else if (type.endsWith("[]")) {
            final Class<?> memberType = javaTypeToClass(cu, type.substring(0, type.length() - 2));
            if (memberType == null) {
                return null;
            }
            return Array.newInstance(memberType, 0).getClass();
        } else { //class name
            final ClassLoader ic = getInternalClassloader();
            final String typeNoGenerics = eraseGenericParameters(type);
            final ArrayList<String> possiblePackageQualifiers = possiblePackageQualifiers(cu, typeNoGenerics);
            for (String possiblePackageQualifier : possiblePackageQualifiers) {
                String typeNameLoop = typeNoGenerics;
                do {
                    Class<?> retVal = null;
                    try {
                        retVal = Class.forName(possiblePackageQualifier + typeNameLoop);
                    } catch (ClassNotFoundException e) {
                        try {
                            retVal = ic.loadClass(possiblePackageQualifier + typeNameLoop);
                        } catch (ClassNotFoundException e1) {
                            retVal = null;
                        }
                    }
                    if (retVal != null) {
                        return retVal;
                    }
                    //tries to replace the last dot with a dollar and reload
                    final int lastIndexOfDot = typeNameLoop.lastIndexOf('.');
                    if (lastIndexOfDot == -1) {
                        //nothing more to try with this package qualifier
                        break;
                    }
                    final StringBuilder newTypeNameLoop = new StringBuilder(typeNameLoop);
                    newTypeNameLoop.setCharAt(lastIndexOfDot, '$');
                    typeNameLoop = newTypeNameLoop.toString();
                } while (true);
            }
            return null; //nothing found
        }
    }
    
    private static String eraseGenericParameters(String type) {
        final StringBuilder retVal = new StringBuilder();
        int level = 0;
        for (int i = 0; i < type.length(); ++i) {
            final char current = type.charAt(i);
            if (current == '<') {
                ++level;
            } else if (current == '>') {
                --level;
            } else if (level == 0) {
                retVal.append(current);
            }
        }
        return retVal.toString();
    }
    
    private static ArrayList<String> possiblePackageQualifiers(CompilationUnit cu, String type) {
        final ArrayList<String> retVal = new ArrayList<>();
        retVal.add(""); //always tries with no package qualifier
        retVal.add("java.lang."); //always tries with java.lang (for standard classes that are not imported)
        cu.findAll(ImportDeclaration.class).forEach(id -> {
            final String idString = id.getNameAsString();
            if (id.isAsterisk()) {
                retVal.add(idString + ".");
            } else {
                //if type is A.B.C tries first A, then A.B, then A.B.C
                for (int i = 0; i <= type.length(); ++i) {
                    if (i == type.length() || type.charAt(i) == '.') {
                        final String typePrefix = type.substring(0, i);
                        if (idString.endsWith("." + typePrefix)) {
                            retVal.add(idString.substring(0, idString.length() - typePrefix.length()));
                        }
                    }
                }
            } //else, do not add it
        });
        return retVal;
    }
    
    private static Class<?> inferType(Expression e, HashMap<String, Class<?>> varDecls) {
        if (e.isBooleanLiteralExpr()) {
            return boolean.class;
        } else if (e.isCharLiteralExpr()) {
            return char.class;
        } else if (e.isDoubleLiteralExpr()) {
            return double.class;
        } else if (e.isIntegerLiteralExpr()) {
            return int.class;
        } else if (e.isLongLiteralExpr()) {
            return long.class;
        } else if (e.isArrayAccessExpr()) {
            final Class<?> memberType = inferType(e.asArrayAccessExpr().getName(), varDecls);
            if (memberType == null) {
                return null;
            }
            return Array.newInstance(memberType, 0).getClass();
        } else if (e.isNameExpr() && varDecls.containsKey(e.asNameExpr().getNameAsString())) {
            return varDecls.get(e.asNameExpr().getNameAsString());
        } else {
            return null; //gives up
        }
    }
    
    private static Class<?> classFileTypeToClass(String type) {
        final ClassLoader ic = getInternalClassloader();
        final String typeName = internalToBinaryTypeName(type);
        Class<?> retVal = null;
        try {
            retVal = Class.forName(typeName);
        } catch (ClassNotFoundException e) {
            try {
                retVal = ic.loadClass(typeName);
            } catch (ClassNotFoundException e1) {
                retVal = null;
            }
        }
        return retVal; 
    }
    
    private static String internalToBinaryTypeName(String type) {
        if ("B".equals(type)) {
            return "byte";
        } else if ("C".equals(type)) {
            return "char";
        } else if ("D".equals(type)) {
            return "double";
        } else if ("F".equals(type)) {
            return "float";
        } else if ("I".equals(type)) {
            return "int";
        } else if ("J".equals(type)) {
            return "long";
        } else if ("S".equals(type)) {
            return "short";
        } else if ("Z".equals(type)) {
            return "boolean";
        } else if (type.startsWith("L")){
            return type.substring(1, type.length() - 1).replace('/', '.');
        } else { //array, starts with '['
            return '[' + internalToBinaryTypeName(type.substring(1));
        }
    }

	/**
	 * Do not instantiate!
	 */
	private SeedSplitter() {
		//nothing to do
	}
}
